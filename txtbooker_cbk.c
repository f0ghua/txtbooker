/*@@ Generated by Wedit @@ */
#include <windows.h>
#include <lfc.h>
//#include <netutils.h>
#include <gc.h>
#include <zlib.h>

#include "txtbookerres.h"
#include "msgprintf.h"
#include "regex_helper.h"
#include "encodecvt.h"

#define MAX_STRLEN 256

typedef struct page_info {
	char title[MAX_STRLEN];
	char url[MAX_STRLEN];
} page_info_t;

typedef struct book_info {
	char url[MAX_STRLEN];
	int pages;
	page_info_t pi[1024*5]; // how many pages in a book?
} book_info_t;

book_info_t bi;
book_info_t *g_pbi;

const char g_index_url[128] = "https://www.dawenxue.net/50365/";
const char g_pattern[] 		= "^[ \t]*<dd><a href=\"([^\"]*)\">([^<]*)<.*";
const char g_index_fname[] = "./tmp.html";

long Dlg100ParseSelected(ST_BUTTON *ctrl,struct _Dlg100 *dlg)
{
	char url[MAX_STRLEN], pattern[MAX_STRLEN];
	int i, r;
	FILE *fp;
	char line[1024];
	char ansiOut[1024];

	dlg->idurl->GetWindowText(url, sizeof(url));
	strncpy(url, g_index_url, sizeof(url));

#if 1
	r = GetHttpURL(url, g_index_fname);
	if (r != 0){
		int e = GetLastError();
		ERR("error of gethttpurl = %d", e);
		return -1;
	}
#endif

	g_pbi->pages = 0;
	fp = fopen(g_index_fname, "r");
	while (1) {
		if (fgets(line, sizeof(line), fp) == NULL)
			break;

		enc_convert(line, ansiOut, CP_UTF8, CP_ACP);

		r = regex_match_ERE(ansiOut, g_pattern);
		if (r == 0) {
			snprintf(g_pbi->pi[g_pbi->pages].url, sizeof(g_pbi->pi[g_pbi->pages].url), "%s%s", url, REGEX_MATCH(1));
			//strncpy(g_pbi->pi[g_pbi->pages].url, REGEX_MATCH(1), sizeof(g_pbi->pi[g_pbi->pages].url));
			strncpy(g_pbi->pi[g_pbi->pages].title, REGEX_MATCH(2), sizeof(g_pbi->pi[g_pbi->pages].title));

			g_pbi->pages++;
		}
	}
	fclose(fp);

	LOG("pages = %d", g_pbi->pages);

	for (i = 0; i < g_pbi->pages; i++) {
		dlg->idcbpstart->AddString(g_pbi->pi[i].title);
		dlg->idcbpstart->SetCurSel(0);
		dlg->idcbpend->AddString(g_pbi->pi[i].title);
		dlg->idcbpend->SetCurSel(g_pbi->pages-1);
	}

	return 0;
}

long Dlg100GrabSelected(ST_BUTTON *ctrl,struct _Dlg100 *dlg)
{
	int r = 0, n;
	const char page_fname[] = "./page.html";
	char *p_url = g_pbi->pi[0].url;
	char *p_ansiOut;
	char *p_plain_buf;
	int plbuf_len = 0;
	FILE *fp;
    char *p_content = NULL;
    long bufsize = -1;
	//const char pattern[] = "^[ \t]*<div id=\"content\">([^<]*)</div>.*";
	const char pattern[] = "^[ \t]*<div id=\"content\">(.*)</div>";

#if 1
	LOG("get url = %s", p_url);
	r = GetHttpURL(p_url, page_fname);
	if (r != 0){
		int e = GetLastError();
		ERR("error[%d] of GetHttpURL = %s", e, p_url);
		return -1;
	}
#endif
	p_ansiOut = GC_malloc(1024*10); // 10K should be enough

	fp = fopen(page_fname, "rb");
    if (fp != NULL) {
        /* Go to the end of the file. */
        if (fseek(fp, 0L, SEEK_END) == 0) {
            /* Get the size of the file. */
            bufsize = ftell(fp);
            if (bufsize == -1) { /* Error */
                fclose(fp);
                return -1;
            }

			LOG("read bufsize = %d", bufsize);
        }
        fclose(fp);
    }

	plbuf_len = sizeof(char) * (bufsize + 1) * 4; // gzip can be >2*len, but 4*len should enough
	p_plain_buf = GC_malloc(plbuf_len);
	read_gzip_file(page_fname, p_plain_buf, plbuf_len);

    p_ansiOut = GC_malloc(plbuf_len);
	enc_convert(p_plain_buf, p_ansiOut, CP_UTF8, CP_ACP);

	char *dup = strdup(p_ansiOut);
	char *line = strtok(dup, "\n");
	while(line) {

		r = regex_match_ERE(line, pattern);
		if (r == 0) {
			char *p = REGEX_MATCH(1);
			LOG("found match: %s", line);
			qstrreplace("sr", p, "&nbsp;", " ");
			qstrreplace("sr", p, "<br /><br />", "\n");
			p_content = p;
			break;
		}

   		line  = strtok(NULL, "\n");
	}
	free(dup);

	dlg->idcontent->SetWindowText(p_content);

    GC_free(p_plain_buf);
	GC_free(p_ansiOut);
	return 0;
}

long Dlg100Init(ST_DIALOGBOX *ctrl,struct _Dlg100 *dlg)
{
	int scrWidth, scrHeight;
    RECT rect;

	g_pbi = (book_info_t *)GC_malloc(sizeof(*g_pbi));

    scrWidth = GetSystemMetrics(SM_CXSCREEN);
    scrHeight = GetSystemMetrics(SM_CYSCREEN);
    GetWindowRect(dlg->hwnd, &rect);
#ifndef F_NO_DEBUG
	//LOG("w = %d, h = %d, rect.r,b,l,t = %d,%d,%d,%d",
	//	scrWidth, scrHeight, rect.right, rect.bottom, rect.left, rect.top);
#endif
    SetWindowPos(dlg->hwnd, HWND_TOP,
                 (scrWidth - (rect.right-rect.left)) / 2,
                 (scrHeight - (rect.bottom-rect.top)) / 2,
                 rect.right - rect.left,
                 rect.bottom - rect.top,
                 SWP_SHOWWINDOW);

	return 0;
}

BOOL WINAPI Dlg100Default(HWND hwnd,UINT msg,UINT wParam,DWORD lParam)
{
	return 0;
}

void Dlg100Destroy(HWND hwnd)
{
	EndDialog(hwnd,1);
	GC_free(g_pbi);
	return;
}
